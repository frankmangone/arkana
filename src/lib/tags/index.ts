interface TagDefinition {
  [key: string]: {
    en: string;
    es: string;
    pt: string;
  };
}

export const tags: TagDefinition = {
  abstractAlgebra: {
    en: "Abstract Algebra",
    es: "Álgebra Abstracta",
    pt: "Álgebra Abstracta",
  },
  aptos: {
    en: "Aptos",
    es: "Aptos",
    pt: "Aptos",
  },
  arithmeticCircuits: {
    en: "Arithmetic Circuits",
    es: "Circuitos Aritméticos",
    pt: "Circuitos Aritméticos",
  },
  bitcoin: {
    en: "Bitcoin",
    es: "Bitcoin",
    pt: "Bitcoin",
  },
  blockchain: {
    en: "Blockchain",
    es: "Blockchain",
    pt: "Blockchain",
  },
  blockdag: {
    en: "BlockDAG",
    es: "BlockDAG",
    pt: "BlockDAG",
  },
  commitmentScheme: {
    en: "Commitment Scheme",
    es: "Esquema de Compromiso",
    pt: "Esquema de Compromisso",
  },
  computerScience: {
    en: "Computer Science",
    es: "Ciencia de la Computación",
    pt: "Ciência da Computação",
  },
  conjecture: {
    en: "Conjecture",
    es: "Conjetura",
    pt: "Conjectura",
  },
  consensus: {
    en: "Consensus",
    es: "Consenso",
    pt: "Consenso",
  },
  cpu: {
    en: "CPU",
    es: "CPU",
    pt: "CPU",
  },
  cryptanalysis: {
    en: "Cryptanalysis",
    es: "Criptoanálisis",
    pt: "Criptoanálise",
  },
  cryptocurrency: {
    en: "Cryptocurrency",
    es: "Criptomonedas",
    pt: "Criptomoedas",
  },
  cryptography: {
    en: "Cryptography",
    es: "Criptografía",
    pt: "Criptografia",
  },
  dag: {
    en: "Directed Acyclic Graph",
    es: "Grafo Dirigido Acíclico",
    pt: "Grafo Direcionado Acíclico",
  },
  dataAvailability: {
    en: "Data Availability",
    es: "Disponibilidad de Datos",
    pt: "Disponibilidade de Dados",
  },
  dataStructures: {
    en: "Data Structures",
    es: "Estructuras de Datos",
    pt: "Estruturas de Dados",
  },
  digitalSignatures: {
    en: "Digital Signatures",
    es: "Firmas Digitales",
    pt: "Assinaturas Digitais",
  },
  divisor: {
    en: "Divisor",
    es: "Divisor",
    pt: "Divisor",
  },
  eip: {
    en: "EIP",
    es: "EIP",
    pt: "EIP",
  },
  ellipticCurves: {
    en: "Elliptic Curves",
    es: "Curvas Elípticas",
    pt: "Curvas Elípticas",
  },
  encryption: {
    en: "Encryption",
    es: "Encriptación",
    pt: "Encriptação",
  },
  ether: {
    en: "Ether",
    es: "Ether",
    pt: "Ether",
  },
  ethereum: {
    en: "Ethereum",
    es: "Ethereum",
    pt: "Ethereum",
  },
  evm: {
    en: "EVM",
    es: "EVM",
    pt: "EVM",
  },
  finiteField: {
    en: "Finite Field",
    es: "Campo Finito",
    pt: "Campo Finito",
  },
  function: {
    en: "Function",
    es: "Función",
    pt: "Função",
  },
  gas: {
    en: "Gas",
    es: "Gas",
    pt: "Gas",
  },
  ghostdag: {
    en: "GHOSTDAG",
    es: "GHOSTDAG",
    pt: "GHOSTDAG",
  },
  groups: {
    en: "Groups",
    es: "Grupos",
    pt: "Grupos",
  },
  hardFork: {
    en: "Hard Fork",
    es: "Hard Fork",
    pt: "Hard Fork",
  },
  hashgraph: {
    en: "Hashgraph",
    es: "Hashgraph",
    pt: "Hashgraph",
  },
  hashing: {
    en: "Hashing",
    es: "Hashing",
    pt: "Hashing",
  },
  hedera: {
    en: "Hedera",
    es: "Hedera",
    pt: "Hedera",
  },
  history: {
    en: "History",
    es: "Historia",
    pt: "História",
  },
  homomorphicEncryption: {
    en: "Homomorphic Encryption",
    es: "Encriptación Homomórfica",
    pt: "Encriptação Homomórfica",
  },
  homomorphism: {
    en: "Homomorphism",
    es: "Homomorfismo",
    pt: "Homomorfismo",
  },
  interpolation: {
    en: "Interpolation",
    es: "Interpolación",
    pt: "Interpolação",
  },
  internet: {
    en: "Internet",
    es: "Internet",
    pt: "Internet",
  },
  isomorphism: {
    en: "Isomorphism",
    es: "Isomorfismo",
    pt: "Isomorfismo",
  },
  keyExchange: {
    en: "Key Exchange",
    es: "Intercambio de Claves",
    pt: "Troca de Chaves",
  },
  lattice: {
    en: "Lattice",
    es: "Retículo",
    pt: "Retículo",
  },
  mathematics: {
    en: "Mathematics",
    es: "Matemáticas",
    pt: "Matemática",
  },
  merkleTree: {
    en: "Merkle Tree",
    es: "Árbol de Merkle",
    pt: "Árvore de Merkle",
  },
  mining: {
    en: "Mining",
    es: "Minería",
    pt: "Mineração",
  },
  modularArithmetic: {
    en: "Modular Arithmetic",
    es: "Aritmética Modular",
    pt: "Aritmética Modular",
  },
  pairings: {
    en: "Pairings",
    es: "Emparejamientos",
    pt: "Emparelhamentos",
  },
  parallelization: {
    en: "Parallelization",
    es: "Paralelización",
    pt: "Paralelização",
  },
  patriciaTrie: {
    en: "Patricia Trie",
    es: "Trie de Patricia",
    pt: "Trie de Patricia",
  },
  pectra: {
    en: "Pectra",
    es: "Pectra",
    pt: "Pectra",
  },
  polkadot: {
    en: "Polkadot",
    es: "Polkadot",
    pt: "Polkadot",
  },
  polynomials: {
    en: "Polynomials",
    es: "Polinomios",
    pt: "Polinômios",
  },
  postQuantumCryptography: {
    en: "Post Quantum Cryptography",
    es: "Criptografía Post-Cuántica",
    pt: "Criptografia Pós-Quântica",
  },
  plonk: {
    en: "Plonk",
    es: "Plonk",
    pt: "Plonk",
  },
  privacy: {
    en: "Privacy",
    es: "Privacidad",
    pt: "Privacidade",
  },
  proofOfHistory: {
    en: "Proof of History",
    es: "Prueba de Historia",
    pt: "Prova de História",
  },
  proofOfStake: {
    en: "Proof of Stake",
    es: "Prueba de Participación",
    pt: "Prova de Participação",
  },
  proofOfWork: {
    en: "Proof of Work",
    es: "Prueba de Trabajo",
    pt: "Prova de Trabalho",
  },
  protocol: {
    en: "Protocol",
    es: "Protocolo",
    pt: "Protocolo",
  },
  quantumMechanics: {
    en: "Quantum Mechanics",
    es: "Mecánica Cuántica",
    pt: "Mecânica Quântica",
  },
  qubit: {
    en: "Qubit",
    es: "Qubit",
    pt: "Qubit",
  },
  rationalPoints: {
    en: "Rational Points",
    es: "Puntos Racionales",
    pt: "Pontos Racionais",
  },
  ring: {
    en: "Ring",
    es: "Anillo",
    pt: "Anel",
  },
  ringLearningWithErrors: {
    en: "Ring Learning with Errors",
    es: "Aprendizaje sobre Anillos con Errores",
    pt: "Aprendizado sobre Anéis com Erros",
  },
  riscv: {
    en: "RISC-V",
    es: "RISC-V",
    pt: "RISC-V",
  },
  rollup: {
    en: "Rollup",
    es: "Rollup",
    pt: "Rollup",
  },
  rsa: {
    en: "RSA",
    es: "RSA",
    pt: "RSA",
  },
  setCode: {
    en: "SetCode",
    es: "SetCode",
    pt: "SetCode",
  },
  scalability: {
    en: "Scalability",
    es: "Escalabilidad",
    pt: "Escalabilidade",
  },
  security: {
    en: "Security",
    es: "Seguridad",
    pt: "Segurança",
  },
  sidechain: {
    en: "Sidechain",
    es: "Sidechain",
    pt: "Sidechain",
  },
  snark: {
    en: "SNARK",
    es: "SNARK",
    pt: "SNARK",
  },
  smartContracts: {
    en: "Smart Contracts",
    es: "Contratos Inteligentes",
    pt: "Contratos Inteligentes",
  },
  solana: {
    en: "Solana",
    es: "Solana",
    pt: "Solana",
  },
  solidity: {
    en: "Solidity",
    es: "Solidity",
    pt: "Solidity",
  },
  stark: {
    en: "STARK",
    es: "STARK",
    pt: "STARK",
  },
  sui: {
    en: "Sui",
    es: "Sui",
    pt: "Sui",
  },
  thresholdSignature: {
    en: "Threshold Signature",
    es: "Firma de Umbral",
    pt: "Assinatura de Umbral",
  },
  torsion: {
    en: "Torsion Group",
    es: "Grupo de Torsión",
    pt: "Grupo de Torção",
  },
  transactions: {
    en: "Transactions",
    es: "Transacciones",
    pt: "Transações",
  },
  utxo: {
    en: "UTXO",
    es: "UTXO",
    pt: "UTXO",
  },
  validator: {
    en: "Validator",
    es: "Validador",
    pt: "Validador",
  },
  verifiableRandomness: {
    en: "Verifiable Randomness",
    es: "Aleatoriedad Verificable",
    pt: "Aleatoriedade Verificável",
  },
  zeroKnowledgeProofs: {
    en: "Zero Knowledge Proofs",
    es: "Pruebas de Conocimiento Cero",
    pt: "Provas de Conhecimento Zero",
  },
} as const;

// Create a union type of all tag keys
export type TagKey = keyof typeof tags;

// Helper function to get tag display name
export function getTagDisplayName(tag: TagKey, lang: string): string {
  return tags[tag]?.[lang as keyof (typeof tags)[TagKey]] || (tag as string);
}

// Helper function to get all tags for a specific language
export function getAllTags(
  lang: string
): Array<{ key: TagKey; displayName: string }> {
  return Object.entries(tags).map(([key, translations]) => ({
    key: key as TagKey,
    displayName: translations[lang as keyof typeof translations] || key,
  }));
}
